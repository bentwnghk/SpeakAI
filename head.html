<!-- Primary Meta Tags -->
<title>Mr.ðŸ†– PodcastAI - Convert Documents and Websites into Audio Podcasts</title>
<meta name="title" content="Mr.ðŸ†– PodcastAI - Convert Documents and Websites into Audio Podcasts" />
<meta
  name="description"
  content="Easily convert documents amd websites into audio podcasts. Perfect for listening on the go and making content more accessible."
/>
<!-- Additional Meta Tags -->
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta charset="UTF-8" />
<meta name="author" content="Mr.ðŸ†– AI" />
<meta
  name="keywords"
  content="document to podcast, website to podcast, audio conversion, podcast creation, accessible content"
/>
<link rel="icon" href="/static/icon.png" type="image/png" />

<script>
  function setupApiKeyStorage() {
    const apiKeyElementId = 'mr_ng_ai_hub_api_key_input';
    const apiKeyStorageKey = 'mrNgAiHubApiKey';
    let apiKeyInput = null;
    let attempts = 0;
    const maxAttempts = 50; // Try for 5 seconds (50 * 100ms)

    console.log('Attempting to set up API key storage...');

    const intervalId = setInterval(() => {
      attempts++;
      const apiKeyInputContainer = document.getElementById(apiKeyElementId);
      
      if (apiKeyInputContainer) {
        // Gradio often wraps inputs. The ID might be on a div.
        let potentialInput = apiKeyInputContainer.querySelector('input[type="password"]');
        if (potentialInput) {
            apiKeyInput = potentialInput;
        } else if (apiKeyInputContainer.tagName === 'INPUT' && apiKeyInputContainer.type === 'password') {
            // Or the ID is directly on the input element
            apiKeyInput = apiKeyInputContainer;
        }
      } else {
         // Fallback if ID is directly on the input and not a container
         apiKeyInput = document.getElementById(apiKeyElementId);
      }

      if (apiKeyInput) {
        clearInterval(intervalId);
        // console.log('API key input field found.');

        // Load API key from localStorage
        try {
          const storedApiKey = localStorage.getItem(apiKeyStorageKey);
          if (storedApiKey) {
            // console.log('Stored API key found.');
            apiKeyInput.value = storedApiKey;
            // Dispatch events to ensure Gradio recognizes the change
            apiKeyInput.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));
            apiKeyInput.dispatchEvent(new Event('change', { bubbles: true, cancelable: true }));
            // console.log('API key loaded into input field.');
          } else {
            console.log('No API key found in localStorage.');
          }
        } catch (e) {
          console.error('Error reading from localStorage:', e);
        }

        // Save API key to localStorage on input
        apiKeyInput.addEventListener('input', () => {
          try {
            localStorage.setItem(apiKeyStorageKey, apiKeyInput.value);
            // console.log('API key saved to localStorage.');
          } catch (e) {
            console.error('Error writing to localStorage:', e);
          }
        });
      } else if (attempts >= maxAttempts) {
        clearInterval(intervalId);
        // console.warn(`API key input field with ID "${apiKeyElementId}" (or a password input within it) not found after ${maxAttempts} attempts. Storage functionality will not work.`);
      }
    }, 100); // Check every 100ms
  }

  // Wait for the full page to load, as Gradio might initialize late
  if (document.readyState === 'complete' || document.readyState === 'interactive') {
    setupApiKeyStorage();
  } else {
    window.addEventListener('load', setupApiKeyStorage);
  }

const PODCAST_HISTORY_KEY = 'gradioPdfToPodcastHistory';

function getPodcastHistory() {
    try {
        const history = localStorage.getItem(PODCAST_HISTORY_KEY);
        return history ? JSON.parse(history) : [];
    } catch (e) {
        console.error("Error reading podcast history from localStorage:", e);
        return [];
    }
}

function savePodcastHistory(history) {
    try {
        localStorage.setItem(PODCAST_HISTORY_KEY, JSON.stringify(history));
    } catch (e) {
        console.error("Error saving podcast history to localStorage:", e);
        // Potentially handle quota exceeded error
        alert("Could not save podcast history. Storage might be full.");
    }
}

async function saveNewPodcastToHistory(title, audioFileServerPath, transcriptText) {
    console.log("[SAVE_NEW] Attempting to save podcast:", { title, audioFileServerPath, transcriptLength: transcriptText?.length });
    if (!audioFileServerPath || typeof transcriptText === 'undefined') {
        console.error("[SAVE_NEW] Audio path or transcript is missing.");
        return;
    }

    const historyListElem = document.getElementById('podcastHistoryList');
    let savingMsgElem = document.getElementById('podcastSavingMessage');
    if (!savingMsgElem && historyListElem) {
        savingMsgElem = document.createElement('li');
        savingMsgElem.id = 'podcastSavingMessage';
        savingMsgElem.textContent = 'Saving current podcast to history...';
        savingMsgElem.style.fontStyle = 'italic';
        savingMsgElem.style.padding = '10px';
        savingMsgElem.style.textAlign = 'center';
        historyListElem.prepend(savingMsgElem);
    } else if (savingMsgElem) {
        savingMsgElem.textContent = 'Saving current podcast to history...'; // Update if already exists
    }

    try {
        console.log(`[SAVE_NEW] Fetching audio from: ${audioFileServerPath}`);
        const response = await fetch(audioFileServerPath);
        console.log(`[SAVE_NEW] Fetch response status: ${response.status}`);
        if (!response.ok) {
            throw new Error(`Failed to fetch audio file: ${response.status} ${response.statusText} from ${audioFileServerPath}`);
        }
        const audioBlob = await response.blob();
        console.log(`[SAVE_NEW] Audio blob received, size: ${audioBlob.size}`);
        
        const reader = new FileReader();
        reader.onloadstart = () => console.log("[SAVE_NEW] FileReader: onloadstart");
        reader.onprogress = (event) => console.log(`[SAVE_NEW] FileReader: onprogress - Loaded ${event.loaded} of ${event.total}`);
        reader.onload = () => console.log("[SAVE_NEW] FileReader: onload (about to call onloadend logic)");
        reader.onloadend = function() {
            console.log("[SAVE_NEW] FileReader: onloadend - Conversion to base64 complete.");
            const base64Audio = reader.result;
            if (!base64Audio || !base64Audio.startsWith('data:')) {
                console.error("[SAVE_NEW] FileReader: Base64 audio data is invalid or empty.", base64Audio ? base64Audio.substring(0,100) : "undefined");
                if (savingMsgElem) savingMsgElem.textContent = 'Error: Could not process audio data.';
                setTimeout(() => { if (savingMsgElem) savingMsgElem.remove(); }, 3000);
                return;
            }
            console.log(`[SAVE_NEW] Base64 audio data length: ${base64Audio.length}`);
            const history = getPodcastHistory();
            const newPodcast = {
                id: 'podcast-' + Date.now() + '-' + Math.random().toString(36).substring(2, 7),
                title: title || `Podcast ${new Date().toLocaleString()}`,
                audioDataUrl: base64Audio,
                transcript: transcriptText,
                savedAt: new Date().toISOString()
            };
            history.unshift(newPodcast);
            savePodcastHistory(history);
            if (savingMsgElem) savingMsgElem.remove();
            console.log("[SAVE_NEW] Podcast saved to browser history. Rendering history...");
            renderPodcastHistory();
        }
        reader.onerror = function(error) {
            console.error("[SAVE_NEW] FileReader: onerror - Error converting audio blob to base64:", error);
            if (savingMsgElem) savingMsgElem.textContent = 'Error processing audio for history.';
            setTimeout(() => { if (savingMsgElem) savingMsgElem.remove(); }, 3000);
        }
        reader.onabort = () => console.error("[SAVE_NEW] FileReader: onabort - Reading aborted.");

        console.log("[SAVE_NEW] FileReader: Calling readAsDataURL...");
        reader.readAsDataURL(audioBlob);

    } catch (error) {
        console.error("[SAVE_NEW] Error during saveNewPodcastToHistory (fetch or setup):", error);
        if (savingMsgElem) savingMsgElem.textContent = `Error saving: ${error.message}`;
        setTimeout(() => { if (savingMsgElem) savingMsgElem.remove(); }, 5000);
    }
}

function renderPodcastHistory() {
    console.log("[RENDER_HISTORY] Attempting to render podcast history.");
    const listContainer = document.getElementById('podcastHistoryList');
    if (!listContainer) {
        console.warn("[RENDER_HISTORY] Podcast history list container ('podcastHistoryList') not found in DOM yet.");
        return;
    }
    console.log("[RENDER_HISTORY] List container found. Clearing and populating.");
    listContainer.innerHTML = ''; // Clear existing items
    const history = getPodcastHistory();
    console.log(`[RENDER_HISTORY] Found ${history.length} items in history.`);

    if (history.length === 0) {
        const emptyMsg = document.createElement('li');
        emptyMsg.textContent = 'No podcasts in history.';
        emptyMsg.style.padding = '10px';
        emptyMsg.style.textAlign = 'center';
        listContainer.appendChild(emptyMsg);
        return;
    }

    history.forEach(podcast => {
        const item = document.createElement('li');
        item.style.marginBottom = '10px';
        item.style.padding = '10px';
        item.style.border = '1px solid #e0e0e0';
        item.style.borderRadius = '4px';
        item.style.display = 'flex';
        item.style.flexDirection = 'column';

        const titleSpan = document.createElement('span');
        titleSpan.textContent = `${podcast.title}`;
        titleSpan.style.fontWeight = 'bold';
        titleSpan.style.marginBottom = '5px';

        const dateSpan = document.createElement('span');
        dateSpan.textContent = `Saved: ${new Date(podcast.savedAt).toLocaleString()}`;
        dateSpan.style.fontSize = '0.9em';
        dateSpan.style.color = '#666';
        dateSpan.style.marginBottom = '8px';
        
        const buttonContainer = document.createElement('div');

        const loadButton = document.createElement('button');
        loadButton.textContent = 'Load';
        loadButton.className = 'gr-button gr-button-sm gr-button-secondary'; // Gradio-like styling
        loadButton.onclick = () => loadPodcastFromHistory(podcast.id);
        loadButton.style.marginRight = '5px';
        
        const deleteButton = document.createElement('button');
        deleteButton.textContent = 'Delete';
        deleteButton.className = 'gr-button gr-button-sm gr-button-stop'; // Gradio-like styling
        deleteButton.onclick = () => deletePodcastFromHistory(podcast.id);

        item.appendChild(titleSpan);
        item.appendChild(dateSpan);
        buttonContainer.appendChild(loadButton);
        buttonContainer.appendChild(deleteButton);
        item.appendChild(buttonContainer);
        listContainer.appendChild(item);
    });
}

function loadPodcastFromHistory(podcastId) {
    const history = getPodcastHistory();
    const podcast = history.find(p => p.id === podcastId);
    if (podcast) {
        const audioPlayerElement = document.querySelector('#podcast_audio_player audio');
        const transcriptDisplayElement = document.querySelector('#podcast_transcript_display textarea');

        if (audioPlayerElement) {
            audioPlayerElement.src = podcast.audioDataUrl;
            // Ensure the parent gr.Audio component is visible if Gradio hides it
            const audioWrapper = audioPlayerElement.closest('.gr-audio');
            if (audioWrapper) audioWrapper.style.display = 'block';
        } else {
            console.error("Audio player element ('#podcast_audio_player audio') not found for loading.");
            alert("Could not find audio player to load podcast.");
            return;
        }
        if (transcriptDisplayElement) {
            transcriptDisplayElement.value = podcast.transcript;
            // Trigger input event for Gradio to recognize change if it relies on it
            const inputEvent = new Event('input', { bubbles: true, cancelable: true });
            transcriptDisplayElement.dispatchEvent(inputEvent);
        } else {
            console.error("Transcript display element ('#podcast_transcript_display textarea') not found for loading.");
            alert("Could not find transcript display to load podcast.");
            return;
        }
        console.log(`Loaded '${podcast.title}' from history.`);
        // Scroll to top or to the player for better UX
        window.scrollTo({ top: 0, behavior: 'smooth' });
    }
}

function deletePodcastFromHistory(podcastId) {
    if (!confirm("Are you sure you want to delete this podcast from history?")) {
        return;
    }
    let history = getPodcastHistory();
    history = history.filter(p => p.id !== podcastId);
    savePodcastHistory(history);
    renderPodcastHistory();
    console.log("Podcast deleted from history.");
}

function initializePodcastHistoryFeature() {
    let attempts = 0;
    const maxAttempts = 60; // Increased to 6 seconds
    console.log("[INIT_HISTORY_FEATURE] Initializing. Waiting for list container...");
    const interval = setInterval(() => {
        const listContainer = document.getElementById('podcastHistoryList');
        if (listContainer) {
            clearInterval(interval);
            console.log("[INIT_HISTORY_FEATURE] Podcast history list container found. Rendering history.");
            renderPodcastHistory();
        } else {
            attempts++;
            if (attempts % 10 === 0) { // Log every second
                 console.log(`[INIT_HISTORY_FEATURE] Waiting for list container... attempt ${attempts}`);
            }
            if (attempts >= maxAttempts) {
                clearInterval(interval);
                console.warn("[INIT_HISTORY_FEATURE] Podcast history list container ('podcastHistoryList') NOT FOUND after multiple attempts.");
            }
        }
    }, 100);
}

function initializeJsTriggerObserver() {
    const targetNodeId = 'js_trigger_data_textbox';
    let inputElement = null;
    let attempts = 0;
    const maxAttempts = 60; // 6 seconds
    let lastProcessedValue = null; // To prevent reprocessing the same data

    console.log('[INIT_TRIGGER_OBSERVER] Attempting to set up JS Trigger Observer...');

    const findInputElementInterval = setInterval(() => {
        attempts++;
        const wrapperDiv = document.getElementById(targetNodeId);
        if (wrapperDiv) {
            // Gradio's Textbox component usually renders a <textarea> inside a div that has the elem_id.
            inputElement = wrapperDiv.querySelector('textarea');
            if (!inputElement) {
                 inputElement = wrapperDiv.querySelector('input[type="text"]'); // Fallback
                 if(inputElement) console.log("[INIT_TRIGGER_OBSERVER] Found input[type='text'] as target.");
            } else {
                 console.log("[INIT_TRIGGER_OBSERVER] Found textarea as target.");
            }
        } else {
            if (attempts % 10 === 0) console.log(`[INIT_TRIGGER_OBSERVER] Wrapper div #${targetNodeId} not found yet. Attempt: ${attempts}`);
        }

        if (inputElement) {
            clearInterval(findInputElementInterval);
            console.log('[INIT_TRIGGER_OBSERVER] JS Trigger Textbox input element found:', inputElement);

            const observer = new MutationObserver((mutationsList) => {
                // We are observing the input/textarea itself. Gradio changes its 'value' property.
                // The 'attributes' filter with 'value' might not always catch programmatic .value changes for textarea.
                // A more direct way is to just check the value if any mutation occurs on the element.
                // However, Gradio might also replace the element or its parent, so observing the wrapper might be safer if issues persist.
                // For now, let's assume the inputElement itself is stable and its value property is updated.
                
                const currentValue = inputElement.value; // Read current value directly
                
                // Check if there's new, non-empty data and it's different from the last processed one
                if (currentValue && currentValue !== lastProcessedValue) {
                    console.log('[TRIGGER_OBSERVER] MutationObserver detected potential change. Current value:', currentValue.substring(0, 100) + "...");
                    lastProcessedValue = currentValue; // Update last processed value immediately
                    try {
                        const data = JSON.parse(currentValue);
                        if (data && data.title && data.audio_url && typeof data.transcript !== 'undefined') {
                            console.log('[TRIGGER_OBSERVER] Parsed data successfully. Calling saveNewPodcastToHistory.', data);
                            saveNewPodcastToHistory(data.title, data.audio_url, data.transcript);
                        } else {
                            console.error("[TRIGGER_OBSERVER] Parsed data from trigger textbox is incomplete or malformed:", data);
                        }
                    } catch (e) {
                        console.error("[TRIGGER_OBSERVER] Error parsing JSON from js_trigger_data_textbox:", e, "Raw data:", currentValue);
                    }
                } else if (currentValue === lastProcessedValue && currentValue) {
                    // console.log('[TRIGGER_OBSERVER] Value is same as last processed. Ignoring.');
                }
            });
            
            // Observe the input/textarea element for changes to its properties or content.
            // 'subtree' and 'childList' are more relevant for textareas if Gradio modifies the text node directly.
            // 'attributes' is good for input elements if 'value' attribute is set.
            // 'characterData' for direct text changes within.
            // A combination is safest.
            observer.observe(inputElement, { attributes: true, childList: true, subtree: true, characterData: true });
            console.log('[INIT_TRIGGER_OBSERVER] MutationObserver is now observing the input/textarea element.');

            // Also, Gradio might trigger 'input' or 'change' events when it sets the value.
            // Listening to these can be an alternative or supplement to MutationObserver.
            inputElement.addEventListener('input', () => {
                const currentValue = inputElement.value;
                if (currentValue && currentValue !== lastProcessedValue) {
                    console.log('[TRIGGER_OBSERVER] "input" event detected. Current value:', currentValue.substring(0, 100) + "...");
                    // Logic is same as in MutationObserver, could be refactored
                    lastProcessedValue = currentValue;
                    try {
                        const data = JSON.parse(currentValue);
                        if (data && data.title && data.audio_url && typeof data.transcript !== 'undefined') {
                            saveNewPodcastToHistory(data.title, data.audio_url, data.transcript);
                        } else { console.error("[TRIGGER_OBSERVER] 'input' event: Parsed data incomplete."); }
                    } catch (e) { console.error("[TRIGGER_OBSERVER] 'input' event: Error parsing JSON:", e); }
                }
            });
             console.log('[INIT_TRIGGER_OBSERVER] Added "input" event listener to the input/textarea element.');


        } else if (attempts >= maxAttempts) {
            clearInterval(findInputElementInterval);
            console.warn(`[INIT_TRIGGER_OBSERVER] JS Trigger Textbox with ID "${targetNodeId}" (or its input element) NOT FOUND after ${maxAttempts} attempts.`);
        }
    }, 100);
}


// Wait for Gradio to be ready or use DOMContentLoaded
document.addEventListener('DOMContentLoaded', () => {
    console.log("[DOM_CONTENT_LOADED] DOM fully loaded and parsed.");
    initializePodcastHistoryFeature();
    initializeJsTriggerObserver();
});

</script>
