<!-- Primary Meta Tags -->
<title>Mr.ðŸ†– PodcastAI - Convert Documents and Websites into Audio Podcasts</title>
<meta name="title" content="Mr.ðŸ†– PodcastAI - Convert Documents and Websites into Audio Podcasts" />
<meta
  name="description"
  content="Easily convert documents amd websites into audio podcasts. Perfect for listening on the go and making content more accessible."
/>
<!-- Additional Meta Tags -->
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta charset="UTF-8" />
<meta name="author" content="Mr.ðŸ†– AI" />
<meta
  name="keywords"
  content="document to podcast, website to podcast, audio conversion, podcast creation, accessible content"
/>
<link rel="icon" href="/static/icon.png" type="image/png" />

<script>
  console.log("[HEAD_SCRIPT] Script block parsing started.");

  window.onerror = function(message, source, lineno, colno, error) {
    console.error("[GLOBAL_ERROR] Uncaught Exception:", { message, source, lineno, colno, error: error ? error.stack : 'No error object' });
    return true;
  };
  console.log("[HEAD_SCRIPT] Global error handler set.");

  const PODCAST_HISTORY_KEY = 'gradioPdfToPodcastHistory';

  function getPodcastHistory() {
    try {
        const history = localStorage.getItem(PODCAST_HISTORY_KEY);
        return history ? JSON.parse(history) : [];
    } catch (e) {
        console.error("[GET_HISTORY] Error reading:", e);
        return [];
    }
  }

  function savePodcastHistory(history) {
    try {
        localStorage.setItem(PODCAST_HISTORY_KEY, JSON.stringify(history));
    } catch (e) {
        console.error("[SAVE_HISTORY] Error saving:", e);
        alert("Could not save podcast history. Storage might be full.");
    }
  }

  function renderPodcastHistory() {
    console.log("[RENDER_HISTORY] Attempting to render.");
    const listContainer = document.getElementById('podcastHistoryList');
    if (!listContainer) {
        console.warn("[RENDER_HISTORY] 'podcastHistoryList' element NOT FOUND.");
        // Update the placeholder directly if it's the initial "Loading history..."
        const accordionContent = document.querySelector('#podcastHistoryList'); // Re-query, Gradio might replace it
        if (accordionContent && accordionContent.innerHTML.includes('Loading history...')) {
            accordionContent.innerHTML = '<li style="padding: 10px; text-align: center;">History element not found by JS yet.</li>';
        }
        return;
    }
    listContainer.innerHTML = ''; // Clear
    const history = getPodcastHistory();
    if (history.length === 0) {
        listContainer.innerHTML = '<li style="padding: 10px; text-align: center;">No podcasts in history.</li>';
    } else {
        // Simplified rendering for now
        history.forEach(p => {
            const item = document.createElement('li');
            item.textContent = p.title;
            listContainer.appendChild(item);
        });
    }
    console.log(`[RENDER_HISTORY] Rendered ${history.length} items.`);
  }

  // Functions to be initialized later
  let initializeJsTriggerObserver = function() { console.warn("initializeJsTriggerObserver called before definition (should be redefined by waitForGradioElements)."); };
  let saveNewPodcastToHistory = async function() { console.warn("saveNewPodcastToHistory called before definition."); };


  function actualInitialization() {
    console.log("[ACTUAL_INIT] All necessary Gradio elements presumed available. Initializing features.");
    
    // Redefine more complex functions now
    saveNewPodcastToHistory = async function(title, audioFileServerPath, transcriptText) {
        console.log("[SAVE_NEW] Attempting to save podcast:", { title, audioFileServerPath, transcriptLength: transcriptText?.length });
        if (!audioFileServerPath || typeof transcriptText === 'undefined') {
            console.error("[SAVE_NEW] Audio path or transcript is missing."); return;
        }
        if (!audioFileServerPath.startsWith('/file=')) {
            console.error(`[SAVE_NEW] Invalid audioFileServerPath format: ${audioFileServerPath}.`); return;
        }
        const historyListElem = document.getElementById('podcastHistoryList'); // For saving message
        let savingMsgElem = document.getElementById('podcastSavingMessage');
        if (!savingMsgElem && historyListElem) {
            savingMsgElem = document.createElement('li');
            savingMsgElem.id = 'podcastSavingMessage';
            savingMsgElem.textContent = 'Saving...';
            savingMsgElem.style.fontStyle = 'italic'; historyListElem.prepend(savingMsgElem);
        } else if (savingMsgElem) { savingMsgElem.textContent = 'Saving...';}

        try {
            const response = await fetch(audioFileServerPath);
            if (!response.ok) throw new Error(`Fetch failed: ${response.status}`);
            const audioBlob = await response.blob();
            const reader = new FileReader();
            reader.onloadend = function() {
                const base64Audio = reader.result;
                if (!base64Audio || !base64Audio.startsWith('data:')) {
                    console.error("[SAVE_NEW] FileReader: Base64 audio data invalid.");
                    if(savingMsgElem) savingMsgElem.textContent = 'Error processing audio.';
                    setTimeout(() => { if (savingMsgElem) savingMsgElem.remove(); }, 3000);
                    return;
                }
                const history = getPodcastHistory();
                history.unshift({
                    id: 'podcast-' + Date.now(), title, audioDataUrl: base64Audio, transcript: transcriptText, savedAt: new Date().toISOString()
                });
                savePodcastHistory(history);
                if (savingMsgElem) savingMsgElem.remove();
                renderPodcastHistory();
                console.log("[SAVE_NEW] Podcast saved and history rendered.");
            };
            reader.onerror = () => { console.error("[SAVE_NEW] FileReader error."); if(savingMsgElem) savingMsgElem.textContent = 'File reader error.';};
            reader.readAsDataURL(audioBlob);
        } catch (error) {
            console.error("[SAVE_NEW] Error in saveNewPodcastToHistory:", error);
            if(savingMsgElem) savingMsgElem.textContent = `Save error: ${error.message}`;
        }
    };

    initializeJsTriggerObserver = function() {
        const targetNodeId = 'js_trigger_data_textbox';
        let inputElement = null;
        let attempts = 0;
        const maxAttemptsObserver = 30; // 3 seconds for this specific element
        let lastProcessedValue = "INITIAL_NULL_VALUE_NEVER_TO_BE_REPEATED"; // Initialize to a unique string
        console.log('[INIT_TRIGGER_OBSERVER] Setting up trigger detection...');

        const findAndObserveInterval = setInterval(() => {
            attempts++;
            const wrapperDiv = document.getElementById(targetNodeId);
            if (wrapperDiv) {
                inputElement = wrapperDiv.querySelector('textarea');
                if (!inputElement) inputElement = wrapperDiv.querySelector('input[type="text"]');
            }

            if (inputElement) {
                clearInterval(findAndObserveInterval);
                console.log('[INIT_TRIGGER_OBSERVER] Trigger input/textarea element found:', inputElement.tagName);
                
                const processData = (currentVal, source) => {
                    console.log(`[PROCESS_DATA] Called from ${source}. CurrentVal (first 50 chars):`, currentVal ? currentVal.substring(0,50) : "undefined/empty", "Last processed:", lastProcessedValue ? lastProcessedValue.substring(0,50) : "undefined/empty");
                    // Process if currentVal is not empty AND it's different from the last processed value
                    if (currentVal && currentVal !== lastProcessedValue) {
                        console.log('[PROCESS_DATA] Value is new and non-empty. Processing:', currentVal.substring(0, 100) + "...");
                        lastProcessedValue = currentVal; // Update last processed value
                        try {
                            const data = JSON.parse(currentVal);
                            if (data && data.title && data.audio_url && typeof data.transcript !== 'undefined') {
                                console.log('[PROCESS_DATA] Parsed data successfully. Calling saveNewPodcastToHistory.');
                                saveNewPodcastToHistory(data.title, data.audio_url, data.transcript);
                            } else {
                                console.error("[PROCESS_DATA] Parsed data from trigger textbox is incomplete or malformed:", data);
                            }
                        } catch (e) {
                            console.error("[PROCESS_DATA] Error parsing JSON:", e, "Raw data:", currentVal);
                        }
                    } else if (!currentVal) {
                        console.log("[PROCESS_DATA] Value is empty. Ignoring.");
                    } else {
                        console.log("[PROCESS_DATA] Value is same as last processed. Ignoring.");
                    }
                };

                // Listener for 'input' event
                inputElement.addEventListener('input', (event) => {
                    console.log('[EVENT_LISTENER] "input" event fired on trigger textbox.');
                    processData(event.target.value, "input event");
                });
                console.log('[INIT_TRIGGER_OBSERVER] "input" event listener attached.');

                // MutationObserver as a more general detection mechanism
                const observer = new MutationObserver((mutationsList) => {
                    // console.log('[MUTATION_OBSERVER] Mutation detected on trigger textbox wrapper or its children.');
                    // We are interested in the value of the inputElement itself.
                    processData(inputElement.value, "MutationObserver");
                });
                
                // Observe the inputElement itself for attribute changes (like 'value' for input)
                // and childList/characterData for textarea content changes.
                observer.observe(inputElement, {
                    attributes: true,
                    childList: true,
                    subtree: true, // For text nodes within textarea
                    characterData: true
                });
                console.log('[INIT_TRIGGER_OBSERVER] MutationObserver attached to observe the input/textarea element directly.');

                // Initial check in case Gradio set the value before listeners were attached
                if (inputElement.value) {
                    console.log('[INIT_TRIGGER_OBSERVER] Trigger textbox has an initial value. Processing it.');
                    processData(inputElement.value, "initial check");
                } else {
                    console.log('[INIT_TRIGGER_OBSERVER] Trigger textbox has no initial value.');
                }
                return; // Exit interval once element is found and listeners are set
            }
            
            if (attempts % 10 === 0) console.log(`[INIT_TRIGGER_OBSERVER] Waiting for trigger element #${targetNodeId}... Attempt ${attempts}`);

            if (attempts >= maxAttemptsObserver) {
                clearInterval(findAndObserveInterval);
                console.warn(`[INIT_TRIGGER_OBSERVER] Trigger element #${targetNodeId} (textarea/input) NOT FOUND after ${maxAttemptsObserver} attempts.`);
            }
        }, 100);
    };

    // Call initializations
    renderPodcastHistory(); // Initial render
    initializeJsTriggerObserver();
  }

  function waitForGradioElements() {
    console.log("[WAIT_FOR_GRADIO] Starting to wait for key Gradio elements.");
    let attempts = 0;
    const maxAttempts = 100; // Wait for up to 10 seconds
    // Key elements we need for the history UI and trigger
    const keyElementIds = ['podcastHistoryList', 'js_trigger_data_textbox', 'podcast_audio_player', 'podcast_transcript_display'];
    
    const intervalId = setInterval(() => {
        attempts++;
        let allFound = true;
        for (const id of keyElementIds) {
            const el = document.getElementById(id);
            if (!el) {
                allFound = false;
                if (attempts % 10 === 0) console.log(`[WAIT_FOR_GRADIO] Waiting for element: #${id} (Attempt: ${attempts})`);
                break;
            }
        }

        if (allFound) {
            clearInterval(intervalId);
            console.log("[WAIT_FOR_GRADIO] All key Gradio elements found!");
            actualInitialization();
        } else if (attempts >= maxAttempts) {
            clearInterval(intervalId);
            console.warn("[WAIT_FOR_GRADIO] Timed out waiting for all key Gradio elements. Some features might not work.");
            // Still try to initialize what we can, renderPodcastHistory might partially work if its container is there
            actualInitialization(); 
        }
    }, 100); // Check every 100ms
  }

  // Start the process
  waitForGradioElements();

  console.log("[HEAD_SCRIPT] Script block parsing finished. Polling for Gradio elements initiated.");
</script>
