<!-- Primary Meta Tags -->
<title>Mr.ðŸ†– PodcastAI - Convert Documents and Websites into Audio Podcasts</title>
<meta name="title" content="Mr.ðŸ†– PodcastAI - Convert Documents and Websites into Audio Podcasts" />
<meta
  name="description"
  content="Easily convert documents amd websites into audio podcasts. Perfect for listening on the go and making content more accessible."
/>
<!-- Additional Meta Tags -->
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta charset="UTF-8" />
<meta name="author" content="Mr.ðŸ†– AI" />
<meta
  name="keywords"
  content="document to podcast, website to podcast, audio conversion, podcast creation, accessible content"
/>
<link rel="icon" href="/static/icon.png" type="image/png" />

<script>
  function setupApiKeyStorage() {
    const apiKeyElementId = 'mr_ng_ai_hub_api_key_input';
    const apiKeyStorageKey = 'mrNgAiHubApiKey';
    let apiKeyInput = null;
    let attempts = 0;
    const maxAttempts = 50; // Try for 5 seconds (50 * 100ms)

    console.log('Attempting to set up API key storage...');

    const intervalId = setInterval(() => {
      attempts++;
      const apiKeyInputContainer = document.getElementById(apiKeyElementId);
      
      if (apiKeyInputContainer) {
        // Gradio often wraps inputs. The ID might be on a div.
        let potentialInput = apiKeyInputContainer.querySelector('input[type="password"]');
        if (potentialInput) {
            apiKeyInput = potentialInput;
        } else if (apiKeyInputContainer.tagName === 'INPUT' && apiKeyInputContainer.type === 'password') {
            // Or the ID is directly on the input element
            apiKeyInput = apiKeyInputContainer;
        }
      } else {
         // Fallback if ID is directly on the input and not a container
         apiKeyInput = document.getElementById(apiKeyElementId);
      }

      if (apiKeyInput) {
        clearInterval(intervalId);
        // console.log('API key input field found.');

        // Load API key from localStorage
        try {
          const storedApiKey = localStorage.getItem(apiKeyStorageKey);
          if (storedApiKey) {
            // console.log('Stored API key found.');
            apiKeyInput.value = storedApiKey;
            // Dispatch events to ensure Gradio recognizes the change
            apiKeyInput.dispatchEvent(new Event('input', { bubbles: true, cancelable: true }));
            apiKeyInput.dispatchEvent(new Event('change', { bubbles: true, cancelable: true }));
            // console.log('API key loaded into input field.');
          } else {
            console.log('No API key found in localStorage.');
          }
        } catch (e) {
          console.error('Error reading from localStorage:', e);
        }

        // Save API key to localStorage on input
        apiKeyInput.addEventListener('input', () => {
          try {
            localStorage.setItem(apiKeyStorageKey, apiKeyInput.value);
            // console.log('API key saved to localStorage.');
          } catch (e) {
            console.error('Error writing to localStorage:', e);
          }
        });
      } else if (attempts >= maxAttempts) {
        clearInterval(intervalId);
        // console.warn(`API key input field with ID "${apiKeyElementId}" (or a password input within it) not found after ${maxAttempts} attempts. Storage functionality will not work.`);
      }
    }, 100); // Check every 100ms
  }

  // Wait for the full page to load, as Gradio might initialize late
  if (document.readyState === 'complete' || document.readyState === 'interactive') {
    setupApiKeyStorage();
  } else {
    window.addEventListener('load', setupApiKeyStorage);
  }

const PODCAST_HISTORY_KEY = 'gradioPdfToPodcastHistory';

function getPodcastHistory() {
    try {
        const history = localStorage.getItem(PODCAST_HISTORY_KEY);
        return history ? JSON.parse(history) : [];
    } catch (e) {
        console.error("Error reading podcast history from localStorage:", e);
        return [];
    }
}

function savePodcastHistory(history) {
    try {
        localStorage.setItem(PODCAST_HISTORY_KEY, JSON.stringify(history));
    } catch (e) {
        console.error("Error saving podcast history to localStorage:", e);
        // Potentially handle quota exceeded error
        alert("Could not save podcast history. Storage might be full.");
    }
}

async function saveNewPodcastToHistory(title, audioFileServerPath, transcriptText) {
    console.log("Attempting to save podcast to history:", title, audioFileServerPath);
    if (!audioFileServerPath || typeof transcriptText === 'undefined') {
        console.error("Audio path or transcript is missing for saving to history.");
        return;
    }

    // Show a visual cue to the user that saving is in progress.
    const historyListElem = document.getElementById('podcastHistoryList');
    let savingMsgElem = document.getElementById('podcastSavingMessage');
    if (!savingMsgElem && historyListElem) {
        savingMsgElem = document.createElement('li');
        savingMsgElem.id = 'podcastSavingMessage';
        savingMsgElem.textContent = 'Saving current podcast to history...';
        savingMsgElem.style.fontStyle = 'italic';
        historyListElem.prepend(savingMsgElem);
    }


    try {
        const response = await fetch(audioFileServerPath);
        if (!response.ok) {
            throw new Error(`Failed to fetch audio file: ${response.status} ${response.statusText}`);
        }
        const audioBlob = await response.blob();
        
        const reader = new FileReader();
        reader.readAsDataURL(audioBlob);
        reader.onloadend = function() {
            const base64Audio = reader.result;
            const history = getPodcastHistory();
            const newPodcast = {
                id: 'podcast-' + Date.now() + '-' + Math.random().toString(36).substring(2, 7),
                title: title || `Podcast ${new Date().toLocaleString()}`,
                audioDataUrl: base64Audio,
                transcript: transcriptText,
                savedAt: new Date().toISOString()
            };
            history.unshift(newPodcast);
            // Optional: Limit history size, e.g., to 20 items
            // if (history.length > 20) { history.pop(); }
            savePodcastHistory(history);
            if (savingMsgElem) savingMsgElem.remove();
            renderPodcastHistory();
            console.log("Podcast saved to browser history!");
        }
        reader.onerror = function() {
            console.error("Error converting audio blob to base64 for history.");
            if (savingMsgElem) savingMsgElem.textContent = 'Error processing audio for history.';
            setTimeout(() => { if (savingMsgElem) savingMsgElem.remove(); }, 3000);
        }
    } catch (error) {
        console.error("Error saving podcast to history:", error);
        if (savingMsgElem) savingMsgElem.textContent = `Error saving to history: ${error.message}`;
        setTimeout(() => { if (savingMsgElem) savingMsgElem.remove(); }, 3000);
    }
}

function renderPodcastHistory() {
    const history = getPodcastHistory();
    const listContainer = document.getElementById('podcastHistoryList');
    if (!listContainer) {
        console.warn("Podcast history list container ('podcastHistoryList') not found in DOM yet.");
        return;
    }
    listContainer.innerHTML = ''; // Clear existing items

    if (history.length === 0) {
        const emptyMsg = document.createElement('li');
        emptyMsg.textContent = 'No podcasts in history.';
        emptyMsg.style.padding = '10px';
        emptyMsg.style.textAlign = 'center';
        listContainer.appendChild(emptyMsg);
        return;
    }

    history.forEach(podcast => {
        const item = document.createElement('li');
        item.style.marginBottom = '10px';
        item.style.padding = '10px';
        item.style.border = '1px solid #e0e0e0';
        item.style.borderRadius = '4px';
        item.style.display = 'flex';
        item.style.flexDirection = 'column';

        const titleSpan = document.createElement('span');
        titleSpan.textContent = `${podcast.title}`;
        titleSpan.style.fontWeight = 'bold';
        titleSpan.style.marginBottom = '5px';

        const dateSpan = document.createElement('span');
        dateSpan.textContent = `Saved: ${new Date(podcast.savedAt).toLocaleString()}`;
        dateSpan.style.fontSize = '0.9em';
        dateSpan.style.color = '#666';
        dateSpan.style.marginBottom = '8px';
        
        const buttonContainer = document.createElement('div');

        const loadButton = document.createElement('button');
        loadButton.textContent = 'Load';
        loadButton.className = 'gr-button gr-button-sm gr-button-secondary'; // Gradio-like styling
        loadButton.onclick = () => loadPodcastFromHistory(podcast.id);
        loadButton.style.marginRight = '5px';
        
        const deleteButton = document.createElement('button');
        deleteButton.textContent = 'Delete';
        deleteButton.className = 'gr-button gr-button-sm gr-button-stop'; // Gradio-like styling
        deleteButton.onclick = () => deletePodcastFromHistory(podcast.id);

        item.appendChild(titleSpan);
        item.appendChild(dateSpan);
        buttonContainer.appendChild(loadButton);
        buttonContainer.appendChild(deleteButton);
        item.appendChild(buttonContainer);
        listContainer.appendChild(item);
    });
}

function loadPodcastFromHistory(podcastId) {
    const history = getPodcastHistory();
    const podcast = history.find(p => p.id === podcastId);
    if (podcast) {
        const audioPlayerElement = document.querySelector('#podcast_audio_player audio');
        const transcriptDisplayElement = document.querySelector('#podcast_transcript_display textarea');

        if (audioPlayerElement) {
            audioPlayerElement.src = podcast.audioDataUrl;
            // Ensure the parent gr.Audio component is visible if Gradio hides it
            const audioWrapper = audioPlayerElement.closest('.gr-audio');
            if (audioWrapper) audioWrapper.style.display = 'block';
        } else {
            console.error("Audio player element ('#podcast_audio_player audio') not found for loading.");
            alert("Could not find audio player to load podcast.");
            return;
        }
        if (transcriptDisplayElement) {
            transcriptDisplayElement.value = podcast.transcript;
            // Trigger input event for Gradio to recognize change if it relies on it
            const inputEvent = new Event('input', { bubbles: true, cancelable: true });
            transcriptDisplayElement.dispatchEvent(inputEvent);
        } else {
            console.error("Transcript display element ('#podcast_transcript_display textarea') not found for loading.");
            alert("Could not find transcript display to load podcast.");
            return;
        }
        console.log(`Loaded '${podcast.title}' from history.`);
        // Scroll to top or to the player for better UX
        window.scrollTo({ top: 0, behavior: 'smooth' });
    }
}

function deletePodcastFromHistory(podcastId) {
    if (!confirm("Are you sure you want to delete this podcast from history?")) {
        return;
    }
    let history = getPodcastHistory();
    history = history.filter(p => p.id !== podcastId);
    savePodcastHistory(history);
    renderPodcastHistory();
    console.log("Podcast deleted from history.");
}

function initializePodcastHistoryFeature() {
    // This function is called once the DOM is ready.
    // The container for the history list should be defined in main.py's Gradio layout.
    // We just call renderPodcastHistory to populate it.
    renderPodcastHistory();
}

// Wait for Gradio to be ready or use DOMContentLoaded
document.addEventListener('DOMContentLoaded', initializePodcastHistoryFeature);

</script>
