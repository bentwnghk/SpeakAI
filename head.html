<!-- Primary Meta Tags -->
<title>Mr.ðŸ†– PodcastAI - Convert Documents and Websites into Audio Podcasts</title>
<meta name="title" content="Mr.ðŸ†– PodcastAI - Convert Documents and Websites into Audio Podcasts" />
<meta
  name="description"
  content="Easily convert documents amd websites into audio podcasts. Perfect for listening on the go and making content more accessible."
/>
<!-- Additional Meta Tags -->
<meta name="viewport" content="width=device-width, initial-scale=1" />
<meta charset="UTF-8" />
<meta name="author" content="Mr.ðŸ†– AI" />
<meta
  name="keywords"
  content="document to podcast, website to podcast, audio conversion, podcast creation, accessible content"
/>
<link rel="icon" href="/static/icon.png" type="image/png" />

<script>
  console.log("[HEAD_SCRIPT] Script block parsing started.");

  window.onerror = function(message, source, lineno, colno, error) {
    console.error("[GLOBAL_ERROR] Uncaught Exception:", { message, source, lineno, colno, error: error ? error.stack : 'No error object' });
    return true;
  };
  console.log("[HEAD_SCRIPT] Global error handler set.");

  const PODCAST_HISTORY_KEY = 'gradioPdfToPodcastHistory';

  function getPodcastHistory() {
    try {
        const history = localStorage.getItem(PODCAST_HISTORY_KEY);
        return history ? JSON.parse(history) : [];
    } catch (e) {
        console.error("[GET_HISTORY] Error reading:", e);
        return [];
    }
  }

  function savePodcastHistory(history) {
    try {
        localStorage.setItem(PODCAST_HISTORY_KEY, JSON.stringify(history));
    } catch (e) {
        console.error("[SAVE_HISTORY] Error saving:", e);
        // This alert is now more critical as it's the primary user feedback for quota issues.
        alert("Could not save podcast history. Storage might be full. Large transcripts can also cause this.");
    }
  }

  function renderPodcastHistory() {
    console.log("[RENDER_HISTORY] Attempting to render.");
    const listContainer = document.getElementById('podcastHistoryList');
    if (!listContainer) {
        console.warn("[RENDER_HISTORY] 'podcastHistoryList' element NOT FOUND.");
        const accordionContent = document.querySelector('#podcastHistoryList'); 
        if (accordionContent && accordionContent.innerHTML.includes('Loading history...')) {
            accordionContent.innerHTML = '<li style="padding: 10px; text-align: center;">History element not found by JS yet.</li>';
        }
        return;
    }
    listContainer.innerHTML = ''; // Clear
    const history = getPodcastHistory();
    if (history.length === 0) {
        listContainer.innerHTML = '<li style="padding: 10px; text-align: center;">No podcasts in history.</li>';
    } else {
        history.forEach(podcast => {
            const item = document.createElement('li');
            item.style.marginBottom = '10px';
            item.style.padding = '10px';
            item.style.border = '1px solid #e0e0e0';
            item.style.borderRadius = '4px';
            item.style.display = 'flex';
            item.style.flexDirection = 'column';

            const titleSpan = document.createElement('span');
            titleSpan.textContent = `${podcast.title}`;
            titleSpan.style.fontWeight = 'bold';
            titleSpan.style.marginBottom = '5px';

            const dateSpan = document.createElement('span');
            dateSpan.textContent = `Saved: ${new Date(podcast.savedAt).toLocaleString()}`;
            dateSpan.style.fontSize = '0.9em';
            dateSpan.style.color = '#666';
            dateSpan.style.marginBottom = '8px';
            
            const buttonContainer = document.createElement('div');

            const loadButton = document.createElement('button');
            loadButton.textContent = 'Load';
            loadButton.className = 'gr-button gr-button-sm gr-button-secondary';
            loadButton.onclick = () => loadPodcastFromHistory(podcast.id);
            loadButton.style.marginRight = '5px';
            
            const deleteButton = document.createElement('button');
            deleteButton.textContent = 'Delete';
            deleteButton.className = 'gr-button gr-button-sm gr-button-stop';
            deleteButton.onclick = () => deletePodcastFromHistory(podcast.id);

            item.appendChild(titleSpan);
            item.appendChild(dateSpan);
            buttonContainer.appendChild(loadButton);
            buttonContainer.appendChild(deleteButton);
            item.appendChild(buttonContainer);
            listContainer.appendChild(item);
        });
    }
    console.log(`[RENDER_HISTORY] Rendered ${history.length} items.`);
  }

  let initializeJsTriggerObserver = function() { console.warn("initializeJsTriggerObserver called before definition."); };
  let saveNewPodcastToHistory = async function() { console.warn("saveNewPodcastToHistory called before definition."); };
  let loadPodcastFromHistory = function() { console.warn("loadPodcastFromHistory called before definition.")};
  let deletePodcastFromHistory = function() { console.warn("deletePodcastFromHistory called before definition.")};

  function actualInitialization() {
    console.log("[ACTUAL_INIT] All necessary Gradio elements presumed available. Initializing features.");
    
    loadPodcastFromHistory = function(podcastId) {
        console.log(`[LOAD_HISTORY] Attempting to load podcast ID: ${podcastId}`);
        const history = getPodcastHistory();
        const podcast = history.find(p => p.id === podcastId);
        if (podcast) {
            const audioWrapper = document.getElementById('podcast_audio_player'); // This is the div Gradio creates with the elem_id
            const transcriptDisplayElement = document.querySelector('#podcast_transcript_display textarea');
            let audioPlayerElement = null;

            if (!audioWrapper) {
                console.error("[LOAD_HISTORY] Audio player WRAPPER ('#podcast_audio_player') not found.");
                alert("Could not find the audio player component to load the podcast.");
                return;
            }

            audioPlayerElement = audioWrapper.querySelector('audio');

            if (!audioPlayerElement) {
                console.warn("[LOAD_HISTORY] HTML <audio> element not initially found. Attempting to create or find a suitable container.");
                // Gradio's gr.Audio often has a structure like:
                // <div id="podcast_audio_player" class="gr-audio ...">
                //   <div class="player ..."> <!-- Or similar class -->
                //     <!-- <audio> tag would be here -->
                //   </div>
                // </div>
                // Or sometimes the <audio> tag is directly inside the #podcast_audio_player div.

                let playerContainer = audioWrapper.querySelector('.player'); // A common class Gradio might use
                if (!playerContainer) { // If no specific '.player' div, use the wrapper itself as container
                    playerContainer = audioWrapper;
                    console.log("[LOAD_HISTORY] No '.player' div found, will attempt to append <audio> to the main wrapper.");
                } else {
                    console.log("[LOAD_HISTORY] Found '.player' div, will attempt to append <audio> there.");
                }
                
                // Clear out any placeholder content in the player container if it exists
                // playerContainer.innerHTML = ''; // Be cautious with this, might remove other Gradio elements

                audioPlayerElement = document.createElement('audio');
                audioPlayerElement.setAttribute('controls', '');
                // Common styles Gradio might apply, or use defaults
                audioPlayerElement.style.width = '100%';
                playerContainer.appendChild(audioPlayerElement);
                console.log("[LOAD_HISTORY] Created and appended a new <audio> element.");
            }
            
            // At this point, audioPlayerElement should exist (either found or created)
            console.log(`[LOAD_HISTORY] Using audio element. Setting src to: ${podcast.audioUrl}`);
            audioPlayerElement.src = podcast.audioUrl;
            audioPlayerElement.load(); // Explicitly call load after setting new src

            // Ensure the main wrapper is visible
            audioWrapper.style.display = 'block';
            const innerContainer = audioWrapper.querySelector('.player');
            if (innerContainer) innerContainer.style.display = 'block';
            
            console.log(`[LOAD_HISTORY] Audio player src set for ${podcast.title}`);

            if (transcriptDisplayElement) {
                transcriptDisplayElement.value = podcast.transcript;
                const inputEvent = new Event('input', { bubbles: true, cancelable: true });
                transcriptDisplayElement.dispatchEvent(inputEvent);
                console.log(`[LOAD_HISTORY] Transcript display value set for ${podcast.title}`);
            } else {
                console.error("[LOAD_HISTORY] Transcript display element ('#podcast_transcript_display textarea') not found.");
                alert("Could not find transcript display to load podcast.");
                return;
            }
            console.log(`[LOAD_HISTORY] Loaded '${podcast.title}' from history.`);
            window.scrollTo({ top: 0, behavior: 'smooth' });
        } else {
            console.warn(`[LOAD_HISTORY] Podcast ID ${podcastId} not found in history.`);
        }
    };

    deletePodcastFromHistory = function(podcastId) {
        if (!confirm("Are you sure you want to delete this podcast from history?")) {
            return;
        }
        console.log(`[DELETE_HISTORY] Attempting to delete podcast ID: ${podcastId}`);
        let history = getPodcastHistory();
        history = history.filter(p => p.id !== podcastId);
        savePodcastHistory(history);
        renderPodcastHistory();
        console.log(`[DELETE_HISTORY] Podcast ${podcastId} deleted and history re-rendered.`);
    };

    // MODIFIED saveNewPodcastToHistory:
    saveNewPodcastToHistory = async function(title, audioFileUrlFromComponent, transcriptText) {
        console.log("[SAVE_NEW] Attempting to save podcast metadata:", { title, audioUrl: audioFileUrlFromComponent, transcriptLength: transcriptText?.length });
        if (!audioFileUrlFromComponent || typeof transcriptText === 'undefined') {
            console.error("[SAVE_NEW] Audio URL or transcript is missing."); return;
        }

        console.log(`[SAVE_NEW] Received audioFileUrlFromComponent: ${audioFileUrlFromComponent}`);
        if (typeof audioFileUrlFromComponent !== 'string' || audioFileUrlFromComponent.trim() === '') {
            console.error(`[SAVE_NEW] Invalid or empty audioFileUrlFromComponent: '${audioFileUrlFromComponent}'`);
            // No savingMsgElem handling here as we are not fetching anymore before this point.
            return;
        }
        console.log(`[SAVE_NEW] Valid audioFileUrlFromComponent: ${audioFileUrlFromComponent}`);
        
        const historyListElem = document.getElementById('podcastHistoryList'); // For potential (but removed) saving message
        // let savingMsgElem = document.getElementById('podcastSavingMessage'); // No longer needed here as fetch is removed

        try {
            // We are now storing the URL directly, no fetch or FileReader needed here.
            const history = getPodcastHistory();
            const newPodcast = {
                id: 'podcast-' + Date.now() + '-' + Math.random().toString(36).substring(2, 7),
                title: title,
                audioUrl: audioFileUrlFromComponent, // Store the direct URL
                transcript: transcriptText,
                savedAt: new Date().toISOString()
            };
            history.unshift(newPodcast);
            savePodcastHistory(history); // This is where QuotaExceededError might happen

            // if (savingMsgElem) savingMsgElem.remove(); // Not strictly needed now
            renderPodcastHistory(); 
            console.log("[SAVE_NEW] Podcast metadata (with URL) saved and history rendered.");

        } catch (error) { 
            console.error("[SAVE_NEW] Error saving podcast metadata to history (e.g. from get/savePodcastHistory):", error);
            // The alert for QuotaExceededError is handled inside savePodcastHistory itself.
        }
    };

    initializeJsTriggerObserver = function() {
        const targetNodeId = 'js_trigger_data_textbox';
        let inputElement = null;
        let attempts = 0;
        const maxAttemptsObserver = 30; 
        let lastProcessedValue = "INITIAL_NULL_VALUE_NEVER_TO_BE_REPEATED"; 
        console.log('[INIT_TRIGGER_OBSERVER] Setting up trigger detection...');

        const findAndObserveInterval = setInterval(() => {
            attempts++;
            const wrapperDiv = document.getElementById(targetNodeId);
            if (wrapperDiv) {
                inputElement = wrapperDiv.querySelector('textarea');
                if (!inputElement) inputElement = wrapperDiv.querySelector('input[type="text"]');
            }

            if (inputElement) {
                clearInterval(findAndObserveInterval);
                console.log('[INIT_TRIGGER_OBSERVER] Trigger input/textarea element found:', inputElement.tagName);
                
                const processData = (currentVal, source) => {
                    console.log(`[PROCESS_DATA] Called from ${source}. CurrentVal (first 50 chars):`, currentVal ? currentVal.substring(0,50) : "undefined/empty", "Last processed:", lastProcessedValue ? lastProcessedValue.substring(0,50) : "undefined/empty");
                    if (currentVal && currentVal !== lastProcessedValue) {
                        console.log('[PROCESS_DATA] Value is new and non-empty. Processing:', currentVal.substring(0, 100) + "...");
                        lastProcessedValue = currentVal; 
                        try {
                            const data = JSON.parse(currentVal);
                            if (data && data.title && data.audio_file_component_id && typeof data.transcript !== 'undefined') {
                                console.log('[PROCESS_DATA] Parsed data successfully. Attempting to get audio URL from component:', data.audio_file_component_id);
                                const audioFileComponentWrapper = document.getElementById(data.audio_file_component_id);
                                if (audioFileComponentWrapper) {
                                    const downloadLink = audioFileComponentWrapper.querySelector('a[href]');
                                    if (downloadLink && downloadLink.href) {
                                        const audioUrlFromComponent = downloadLink.href;
                                        console.log('[PROCESS_DATA] Found audio URL from component:', audioUrlFromComponent);
                                        // Pass the extracted URL (audioUrlFromComponent) to saveNewPodcastToHistory
                                        saveNewPodcastToHistory(data.title, audioUrlFromComponent, data.transcript);
                                    } else {
                                        console.error(`[PROCESS_DATA] Could not find a download link with href inside component #${data.audio_file_component_id}. Retrying once.`);
                                        setTimeout(() => { 
                                            const updatedLink = document.getElementById(data.audio_file_component_id)?.querySelector('a[href]');
                                            if (updatedLink && updatedLink.href) {
                                                console.log('[PROCESS_DATA] Retry: Found audio URL from component:', updatedLink.href);
                                                saveNewPodcastToHistory(data.title, updatedLink.href, data.transcript);
                                            } else {
                                                console.error(`[PROCESS_DATA] Retry: Still could not find download link in component #${data.audio_file_component_id}.`);
                                            }
                                        }, 1000); 
                                    }
                                } else {
                                    console.error(`[PROCESS_DATA] Could not find audio file component wrapper with ID: #${data.audio_file_component_id}`);
                                }
                            } else { 
                                console.error("[PROCESS_DATA] Parsed data from trigger textbox is incomplete or malformed:", data);
                            }
                        } catch (e) { 
                            console.error("[PROCESS_DATA] Error parsing JSON:", e, "Raw data:", currentVal);
                        }
                    } else if (!currentVal) {
                        console.log("[PROCESS_DATA] Value is empty. Ignoring.");
                    } else {
                        console.log("[PROCESS_DATA] Value is same as last processed. Ignoring.");
                    }
                };

                inputElement.addEventListener('input', (event) => {
                    console.log('[EVENT_LISTENER] "input" event fired on trigger textbox.');
                    processData(event.target.value, "input event");
                });
                console.log('[INIT_TRIGGER_OBSERVER] "input" event listener attached.');

                const observer = new MutationObserver(() => {
                     console.log('[MUTATION_OBSERVER] Mutation detected on trigger textbox.');
                    processData(inputElement.value, "MutationObserver");
                });
                observer.observe(inputElement, { attributes: true, childList: true, subtree: true, characterData: true });
                console.log('[INIT_TRIGGER_OBSERVER] MutationObserver attached.');

                if (inputElement.value) {
                    console.log('[INIT_TRIGGER_OBSERVER] Trigger textbox has an initial value. Processing it.');
                    processData(inputElement.value, "initial check");
                } else {
                    console.log('[INIT_TRIGGER_OBSERVER] Trigger textbox has no initial value.');
                }
                return; 
            }
            
            if (attempts % 10 === 0) console.log(`[INIT_TRIGGER_OBSERVER] Waiting for trigger element #${targetNodeId}... Attempt ${attempts}`);

            if (attempts >= maxAttemptsObserver) {
                clearInterval(findAndObserveInterval);
                console.warn(`[INIT_TRIGGER_OBSERVER] Trigger element #${targetNodeId} (textarea/input) NOT FOUND after ${maxAttemptsObserver} attempts.`);
            }
        }, 100);
    };

    renderPodcastHistory(); 
    initializeJsTriggerObserver();
  }

  function waitForGradioElements() {
    console.log("[WAIT_FOR_GRADIO] Starting to wait for key Gradio elements.");
    let attempts = 0;
    const maxAttempts = 100; 
    const keyElementIds = ['podcastHistoryList', 'js_trigger_data_textbox', 'podcast_audio_player', 'podcast_transcript_display'];
    
    const intervalId = setInterval(() => {
        attempts++;
        let allFound = true;
        for (const id of keyElementIds) {
            const el = document.getElementById(id);
            if (!el) {
                allFound = false;
                if (attempts % 10 === 0) console.log(`[WAIT_FOR_GRADIO] Waiting for element: #${id} (Attempt: ${attempts})`);
                break;
            }
        }

        if (allFound) {
            clearInterval(intervalId);
            console.log("[WAIT_FOR_GRADIO] All key Gradio elements found!");
            actualInitialization();
        } else if (attempts >= maxAttempts) {
            clearInterval(intervalId);
            console.warn("[WAIT_FOR_GRADIO] Timed out waiting for all key Gradio elements. Some features might not work.");
            actualInitialization(); 
        }
    }, 100); 
  }

  waitForGradioElements();
  console.log("[HEAD_SCRIPT] Script block parsing finished. Polling for Gradio elements initiated.");
</script>
